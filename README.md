# IHW4
Артемьев Александр БПИ227(13 вариант).  
Программа разработана на языке программирования C++ с использованием для работы с потоками функций POSIX Thread.
# Условие:
Первая задача о магазине.
В магазине работают три отдела, каждый отдел обслуживает один продавец. Покупатель, зайдя в магазин, делает покупки в одном или нескольких произвольных отделах, обходя их в произвольном (случайном) порядке. Если в выбранном отделе продавец не свободен, покупатель становится в очередь и ожидает, пока продавец не освободится. Создать многопоточное приложение, моделирующее рабочий день магазина. Каждого покупателя и продавцов моделировать отдельными потоками. Размер очереди не оговаривается. Считается, что для данной задачи она не ограничена (но моделирование должно быть в разумных пределах).
# 4–5 баллов
• Соблюдены общие требования к отчету.  
• В отчете должен быть приведен сценарий, описывающий одновременное поведение представленных в условии задания сущностей в терминах предметной области. То есть, описан сценарий, задающий ролевое поведение субъектов и объектов задачи (интерпрета- ция условия с большей степенью детализации происходящего), а не то, как это будет реализовано в программе.  
• Описана модель параллельных вычислений, используемая при раз- работке многопоточной программы.  
• Описаны входные данные программы, включающие вариативные диапазоны, возможные при многократных запусках.  
• Реализовано консольное приложение, решающее поставленную за- дачу с использованием одного варианта изученных синхропримитивов.  
• Ввод данных в приложение реализован с консоли во время выпол- нения программы (без использования аргументов командной строки).  
• Для используемых генераторов случайных чисел описаны их диа- пазоны и то, как интерпретируются данные этих генераторов.  
• Выводпрограммыдолженбытьинформативным,отражаявсеклю- чевые протекающие в ней события в терминах предметной области. Наблюдатель на основе вывода программы должен понимать, что в ней происходит в каждый момент времени ее работы.  
• В программе присутствуют комментарии, поясняющие выполняе- мые действия и описание используемых объектов и переменных.  
• Результаты работы программы представлены в отчете.  
# Сценарий  
В задаче 2 сущности: покупатель и отдел. Покупатель приходит в магазин и выбирает какие отделы он хотел бы посетить, то есть 1, 2, или 3 продавцов( 0 нерассматривается, так как с точки зрения задачи такой человек не встает в очередь и не производит оплаты, и бессмысленно его учитывать). Для каждого покупателя свой порядок, в котором он будет обходить эти отделы, прийдя в отдел он встает в очередь и ждет пока она не дойдет до него( либо его рассчитывают сразу если она была пуста), после чего идет в следующий отдел из своего списка. Обойдя все отделы, он уходит из магазина и не встречается больше в нашей модели. Продавец стоит в отделе за кассой и ждет когда к нему кто нибудь подойдет, если же перед ним очередь из людей он по порядку рассчитывает их, пока очередь не кончится. Очереди друг от друга никак не зависит, принято, что в каждой свой продавец и они работают синхронно, покупатели тоже друг от друга не зависят(только если они не в одной очереди, тогда один ждет другого).  
# Реализация  
С точки зрения реализации я создал два класса для покупатели и отдела Customer и Departments соответственно.
<img width="552" alt="Снимок экрана 2023-12-21 в 23 27 49" src="https://github.com/Vealar/IHW4/assets/121261496/24bd204d-6fba-41ac-b8cb-7f30b692372e">
<img width="412" alt="Снимок экрана 2023-12-21 в 23 43 36" src="https://github.com/Vealar/IHW4/assets/121261496/2cc7f806-0e91-47bf-a012-df6cdefc8b7d">
Разберем класс Departments:  
Поле id идентефицирует отдел, то есть значение 0 1 2( вообще решение не зависит от количества отделов, можно поменять макрос COUNT_DEPARTMENTS)  
Статическое поле count_customers обозначает количество покупателей во всем магазине  
queue структура данных очередь в которой будут хранится покупателя, в этом отделе в нужном порядке  
mutex для каждой очереди свой, то есть работу в очередях не зависят друг от друга, и ейчас либо расплачиается клиент либо в очередь добавляется человек  
Конструктор и Деструктор для создания и удаления экземпляров класса  
isEmpty проверяет есть ли человек в очереди  
threadDepartments функция которая будет передаваться в поток очереди  
С точки зрения реализации методов, хочется объяснить threadDepartments

<img width="904" alt="Снимок экрана 2023-12-21 в 23 57 39" src="https://github.com/Vealar/IHW4/assets/121261496/8fb77a8d-b152-4e99-8ca1-a414cccd5f80">


Поток будет работать пока в магазине есть покупатели. Если очередь не пуста, мы блокируем queue для работы с ней, расплачиваем покупателя, удаляем его из очереди и выводим сообщение об успехе операции, после чего queue разблокирована. Здесь кроме блокирование самой queue и также есть глобальный MUTEX, который используется для блокировки консоли(без него потоки накладывают сообщения друг на друга)
Разберем класс Customer:
В целом коментарии позволяют понять, что и как используется.
<img width="904" alt="Снимок экрана 2023-12-22 в 00 00 19" src="https://github.com/Vealar/IHW4/assets/121261496/94314708-a6d5-4aef-8482-d767766de272">
Посмотрим на конструктор: мы инициализируем семафор, далее генерируем количество отделов, которые хочет посетить человек.  
Берем вектор order, состоящий из всех отделов, перемешиваем его элементы в рандомном порядке и оставляем только count_departments из них  Следующий метод threadCustomer
<img width="904" alt="Снимок экрана 2023-12-22 в 00 04 09" src="https://github.com/Vealar/IHW4/assets/121261496/5aa20455-33ea-42bb-936d-fe6cf2375c0b">
Метод, который подается в поток покупателя. Покупаетль втсает в очередь для этого блочит ее mutex. Также блочит консоль, чтобы вывести сообщение. И ожидает когда его обслужат. Последний элемент это main  

<img width="904" alt="Снимок экрана 2023-12-22 в 00 08 12" src="https://github.com/Vealar/IHW4/assets/121261496/a83fb346-900f-4a56-9e3a-7aec9655158b">
Здесь мы создаем поток под каждого покупателя и каждый отдел, они отрабатывают и мы их закрываем. Пользователь передает количество покупателей через консоль.
